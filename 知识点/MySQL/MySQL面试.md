[TOC]

# #1 数据库MySQL 

## #1.1 SQL

### #1.1.1 SQL语句

- 建库

```python
// 创建名为students的库
create database students;
```

- 删库

```python
// 删除名为students的库
drop database students;
```

- 建表

```python
// 创建名为stu的表
create table if not exists stu(
    Sid varchar(10),
    Sname char(10)
);
```

- 增

```python
// 插入数据 
insert into stu values('001','Kobe');
```

- 删

```python
// 删除数据 
delete from stu where Sid = '002';
```

```python
// 清空这个表数据 
truncat table stu;
```

- 改

```python
// 修改数据 
update stu set Sname = 'Kobe' where Sid = '008';
```

- 查

```python
// 查询数据 
select * from stu where Sname like 'Kobe%';
```

### #1.1.2 CHAR和VARCHAR的区别？

- CHAR和VARCHAR类型在存储和检索方面有所不同
- CHAR列长度固定为创建表时声明的长度，长度值范围是1到255
- 当CHAR值被存储时，它们被用空格填充到特定长度，检索CHAR值时需删除尾随空格

### #1.1.3 主键和候选键有什么区别？

- 表格的每一行都由主键唯一标识,一个表只有一个主键。
- 主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键引用。

### #1.1.4 myisamchk是用来做什么的？

它用来压缩MyISAM表，这减少了磁盘或内存使用。

### #1.1.5 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？

它会停止递增，任何进一步的插入都将产生错误，因为密钥已被使用。

### #1.1.6 怎样才能找出最后一次插入时分配了哪个自动增量？

LAST_INSERT_ID将返回由Auto_increment分配的最后一个值，并且不需要指定表名称。

### #1.1.7 LIKE声明中的％和_是什么意思？

％对应于0个或更多字符，_只是LIKE语句中的一个字符。

### #1.1.8 NOW（）和CURRENT_DATE（）有什么区别？

- NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。

- CURRENT_DATE（）仅显示当前年份，月份和日期。

### #1.1.9 什么是非标准字符串类型？

- TINYTEXT
- TEXT
- MEDIUMTEXT
- LONGTEXT

### #1.1.10 什么是通用SQL函数？

- CONCAT(A, B) – 连接两个字符串值以创建单个字符串输出。通常用于将两个或多个字段合并为一个字段。
- FORMAT(X, D)- 格式化数字X到D有效数字。
- CURRDATE(), CURRTIME()- 返回当前日期或时间。
- NOW（） – 将当前日期和时间作为一个值返回。
- MONTH（），DAY（），YEAR（），WEEK（），WEEKDAY（） – 从日期值中提取给定数据。
- HOUR（），MINUTE（），SECOND（） – 从时间值中提取给定数据。
- DATEDIFF（A，B） – 确定两个日期之间的差异，通常用于计算年龄
- SUBTIMES（A，B） – 确定两次之间的差异。
- FROMDAYS（INT） – 将整数天数转换为日期值。

### #1.1.11 SQL注入漏洞产生的原因？如何防止？

> SQL注入产生的原因：程序开发过程中不注意规范书写sql语句和对特殊字符进行过滤，导致客户端可以通过全局变量POST和GET提交一些sql语句正常执行。

防止SQL注入的方式：

1. 开启配置文件中的magic_quotes_gpc 和 magic_quotes_runtime设置
2. 执行sql语句时使用addslashes进行sql语句转换
3. Sql语句书写尽量不要省略双引号和单引号。
4. 过滤掉sql语句中的一些关键词：update、insert、delete、select、 * 。
5. 提高数据库表和字段的命名技巧，对一些重要的字段根据程序的特点命名，取不易被猜到的。

## #1.2 存储引擎

### #1.2.1 Mysql中有哪些存储引擎? 

- MyISAM
- Heap
- Merge
- INNODB
- ISAM

### #1.2.2 简述在MySQL数据库中MyISAM和InnoDB的区别

\ | InnoDB | MyISAM
---|---|---
事务 | 支持 | 不支持 |
外键 | 支持 | 不支持 |
锁 | 行锁,适合高并发 | 表锁,不适合高并发 |
总行数 | 不保存 | 保存 |
索引类型 | 聚集索引 | 非聚集索引 |
关注点 | 事务 | 性能 |
表空间 | 大 | 小 |
缓存 | 缓存索引和真实数据,对内存要求高 | 缓存索引,不缓存真实数据 |
全文索引 | 不支持 | 支持 | 

> 表的具体行数

- InnoDB：没有保存表的总行数(只能遍历)，如果使用select count(*) from table；就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。
- MyISAM：保存有表的总行数，如果select count(*) from table;会直接取出出该值。

> CURD操作

- InnoDB：如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。DELETE 从性能上InnoDB更优，但DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用truncate table这个命令。
- MyISAM：如果执行大量的SELECT，MyISAM是更好的选择。

> 查询效率

没有where的count(*)使用MyISAM要比InnoDB快得多。因为MyISAM内置了一个计数器，count(*)时它直接从计数器中读，而InnoDB必须扫描全表。所以在InnoDB上执行count(*)时一般要伴随where，且where中要包含主键以外的索引列。为什么这里特别强调“主键以外”？因为InnoDB中primary index是和raw data存放在一起的，而secondary index则是单独存放，然后有个指针指向primary key。所以只是count(*)的话使用secondary index扫描更快，而primary key则主要在扫描索引同时要返回raw data时的作用较大。MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。

> 通过上述的分析，基本上可以考虑使用InnoDB来替代MyISAM引擎了，原因是InnoDB自身很多良好的特点，比如事务支持、存储 过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。另外，任何一种表都不是万能的，只用恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。

### #1.2.3 如何选择InnoDB/MyISAM

> InnoDB

**用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。**

> MyISAM

**管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。**

> 但是实际场景中，针对具体问题需要具体分析，一般而言可以遵循以下几个问题：

-  数据库是否有外键？
-  是否需要事务支持？
-  是否需要全文索引？
-  数据库经常使用什么样的查询模式？在写多读少的应用中还是Innodb插入性能更稳定，在并发情况下也能基本，如果是对读取速度要求比较快的应用还是选MyISAM。
-  数据库的数据有多大？ 大尺寸倾向于innodb，因为事务日志，故障恢复。


### #1.2.4 innodb为什么要用自增id作为主键

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页

如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE（optimize table）来重建表并优化填充页面。


### #1.2.5 聚集索引与非聚集索引的区别

- 非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据
- 聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。 聚集索引（innodb）的叶节点就是数据节点，而非聚集索引(myisAM)的叶节点仍然是索引节点，只不过其包含一个指向对应数据块的指针。（结合上文）



## #1.3 索引

### #1.3.1 索引分类

- 普通索引
- 唯一索引
- 主键索引
- 组合索引

> 普通索引

普通索引（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。

```
CREATE INDEX index_name ON table(column)
```

修改表时加索引语句：

```
ALTER TABLE table_name ADD INDEX index_name ON (column)
```

> 唯一索引

索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

```
CREATE UNIQUE INDEX indexName ON table(column)
```

修改表时加索引语句：

```
ALTER TABLE table_name ADD UNIQUE indexName ON (column)
```

> 主键索引

是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值。一般是在建表的时候同时创建主键索引。

```
CREATE TABLE 'table' (
    'id' int(11) NOT NULL AUTO_INCREMENT ,   
    PRIMARY KEY ('id')
);
```

> 组合索引

用户可以在多个列上建立索引,这种索引叫做复合索引(组合索引) 查询时使用创建时第一个开始 索引才有效 使用遵循左前缀集合

```
ALTER TABLE `table` ADD INDEX indexName (name,xb,age); 
```

### #1.3.2 索引的目的是什么？

- 快速访问数据表中的特定信息，提高检索速度
- 创建唯一性索引，保证数据库表中每一行数据的唯一性。
- 加速表和表之间的连接

### #1.3.3 索引使用的注意事项

- 索引要用在where条件==经常使用的列==上
- 加索引的列,内容==不要频繁变化==
- ==避免对字段进行null的判断==，因为索引不会生效（可以用一个值代替null，如-999）
- 模糊查询时,使用==like前面==有百分号开头索引会失效,如("%kobe%"这样所以会失效,但是"kobe%"这样子,索引可以正常使用)
- 不要在where条件语句 '=' 的左边进行函数，运算符或表达式的计算，如 select name from tb_user where age/2=20，因为索引不会生效（引擎会放弃使用索引，进行全表扫描）
- 不要使用 <>，！=，not in ，因为索引不会生效
- 避免使用or，可以用union替代（要想使用or，又让索引生效，or条件中的每个列都必须加上索引）
- 使用exist代替in（表中数据越多，exist的效率就比in要越大）
- 如果列类型是字符串，哪作为条件查询时,该列的值一定用' '引号引用起来，否则索引失效：如 select name from user where phone=171117777888;（phone字段在数据库中为varchar类型，应改成 phone='171117777888'）
- 联合索引必须要按照顺序才会生效：如创建的索引顺序为a,b，where a="xx" and b="xx" 生效，但 b="xx" and a="xx" 则不会生效，补充：a="xx" 没有后面的，索引也会生效

### #1.3.4 性别字段为什么不适合加索引

尽量选择区分度高的字段作为索引,区分度的公式是 count(distinct col)/count(*)，表示 字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是 1，而一些状态、 性别字段可能在大数据面前区分度就是 0。在性别字段上增加索引，并不能明显加快检索速度

### #1.3.5 简单描述mysql中，索引，主键，唯一索引，联合索引的区别，对数据库的性能有什么影响（从读写两方面）

- 索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。
- 普通索引(由关键字KEY或INDEX定义的索引)的唯一任务是加快对数据的访问速度。
- 普通索引允许被索引的数据列包含重复的值。如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。也就是说，唯一索引可以保证数据记录的唯一性。
- 主键，是一种特殊的唯一索引，在一张表中只能定义一个主键索引，主键用于唯一标识一条记录，使用关键字 PRIMARY KEY 来创建。
- 索引可以覆盖多个数据列，如像INDEX(columnA, columnB)索引，这就是联合索引。

> 索引可以极大的提高数据的查询速度，但是会降低插入、删除、更新表的速度，因为在执行这些写操作时，还要操作索引文件。

> 使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间

### #1.3.6 如果创建表的时候没有定义主键,会怎么样?

1. 首先判断表中是否有非空的唯一索引(Unique NOT NULL),如果有,则该列即为主键,当表有多个非空唯一索引时,InnoDB存储引擎将选择建表时第一个定义的非空唯一索引(建索引的顺序,不是建表时列的顺序)
2. 如果不符合上述条件,InnoDB存储引擎自动创建一个6个字节大小的指针

### #1.3.7 索引对数据库系统的负面影响是什么？

创建索引和维护索引需要耗费时间，这个时间随着数据量的增加而增加；索引需要占用物理空间，不光是表需要占用数据空间，每个索引也需要占用物理空间；当对表进行增、删、改、的时候索引也要动态维护，这样就降低了数据的维护速度。

### #1.3.8 什么情况下不宜建立索引？

- 对于查询中很少涉及的列或者重复值比较多的列，不宜建立索引。
- 对于一些特殊的数据类型，不宜建立索引，比如文本字段（text）等

### #1.3.9 组合索引和单列索引如何选择? 

- 如果查询where条件只有一个,那么使用单列索引速度快,索引所占空间也比较小
- 如果业务中经常查询多列,不要试图分别基于单个列去建单列索引(因为虽然是多个单列索引,但是MySQL只能用到那个它认为似乎最有效率的单列索引),这是因为当SQL语句所查询的列,全部都出现在复合索引中,此时由于只需要查询索引块即可获得所有数据,当然比使用多个单列索引要快的多.

### #1.3.10 创建索引时需要注意什么

- 非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；
- 取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；
- 索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。
- 唯一、不为空、经常被查询的字段 的字段适合建索引




## #1.4 锁

### #1.4.1 Mysql中有哪几种锁？

- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

> 行锁是InnoDB默认的锁,但是在筛选条件中没有索引字段就会锁住整张表

### #1.4.2 乐观锁与悲观锁 

1. 定义

乐观锁:

> 假设认为数据一般情况下不会造成冲突,所以在数据进行提交更新时,才会正式对数据的冲突与否进行检测,如果发现冲突了,则返回错误信息,让用户决定如何操作

悲观锁:

> 在操作数据时,认为此操作会出现数据冲突,所以在进行每次操作时,都需要通过获取锁才能进行对相同数据的操作,所以悲观锁需要消耗更多的时间 

2. 使用 

乐观锁:

> 乐观锁只是一个概念,并不是数据库自带的,需要用户代码去实现

![20200228174753-image.png](https://raw.githubusercontent.com/Coxhuang/yosoro/master/20200228174753-image.png)

- 表中的version字段是乐观锁在MySQL中的实现
- 更新前查询version

```
select id, version from stu where id = 1;
```

- 根据查询的version以及修改数据(若version被修改,本次更新失败)

```
update stu set name = 'Kobe', version = version + 1 where version = #{version} ;
```

> #{变量名} : 获取变量名对应的值 

悲观锁:

悲观锁的实现与乐观锁不同, 悲观锁是由数据库自己实现的,要用的时候,直接调用数据库相关语句,共享锁和排它锁是悲观锁的不同实现方式,它们俩都属于悲观锁

### #1.4.3 共享锁和排它锁

1. 定义

共享锁: 

共享锁又称读锁(read lock),是读取操作创建的锁,其他用户可以并发读取数据,但任何数据都不能对数据进行修改,直到已释放所有共享锁

排它锁:

排它锁又称写锁(write lock),若某个事务对某一行数据加上排它锁,只能这个事务进行写操作,在此事务结束之前,其他事务不能对其加任何锁,其他进程可以读取,但不能进行写操作

## #1.5 优化

### #1.5.1 SQL语句优化有哪些方法？

- Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。
- 用EXISTS替代IN、用NOT EXISTS替代NOT IN。
- 避免在索引列上使用计算
- 避免在索引列上使用IS NULL和IS NOT NULL
- 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
- 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
- 避免在开头使用模糊查询（%），该查询数据库引擎会放弃索引进行全表扫描,索引失效
- 如果表名或列名过长，就使用别名，因为长的表名和列名也会消耗扫描时间。
- 应尽量避免在 where子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描
- 减少使用 * ，用列名代替

```
select * from user;

要写成: 
select userID, userName, userSalary from user;
```

> 因为在使用 * 的时候，数据库还得查询数据字典，进而解析得到列名，而直接写出列名效率会更高些。


### #1.5.2 Mysql如何优化DISTINCT？

DISTINCT在所有列上转换为GROUP BY，并与ORDER BY子句结合使用。

```
SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;
```

### #1.5.3 MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？

- 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。
- 选择合适的表字段数据类型和存储引擎，适当的添加索引。
- mysql库主从读写分离。
- 找规律分表，减少单表中的数据量提高查询速度。
- 添加缓存机制，比如memcached，apc等。
- 不经常改动的页面，生成静态页面。
- 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.

### #1.5.4 锁的优化策略

- 读写分离
- 分段加锁
- 减少锁持有的时间
- 多个线程尽量以相同的顺序去获取资源

不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。

### #1.5.5 索引的底层实现原理和优化

B+树，经过优化的B+树

主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。

### #1.5.6 如何做 MySQL 的性能优化

- 为搜索字段创建索引
- 避免使用 select *，列出需要查询的字段
- 垂直分割分表
- 选择正确的存储引擎

## #1.6 分布式

### #1.6.1 为什么要MySQL主从

为了减轻服务器处理海量数据并发锁产生的性能问题,其中最主流的方案就是读写分离

### #1.6.2 MySQL读写分离流程

![20200228184947-image.png](https://raw.githubusercontent.com/Coxhuang/yosoro/master/20200228184947-image.png)

- MySQL主服务器对数据操作记录在二进制日志文件(Binary log)中,MySQL将事务串行的写入二进制日志文件
- Slave从服务器将二进制日志文件(Binary log)拷贝到中继日志文件(Relay log)中,首先,Slave开启一个工作线程(I/O thread),具体如下:
1. Slave开启一个工作线程(I/O thread),I/O线程在Master上打开一个连接
2. 开始 binary dump process
3. 如果 binary dump process 已经同步,它会睡眠等待master产生新的事件
4. I/O线程将这些事件写入中继日志文件中
5. SQL Slave thread 从中继文件读取事件,并重放其中的事件而更新Slave数据,使其与Master中的数据一致

### #1.6.3 为什么需要中继文件

由于网络原因, Binary log 不可能一口气存到 I/O thread中,所以Relay log用来缓存Binary log的事件,且Relay log存储在从服务器的缓存中,开销比较小 

### #1.6.4 主从同步的有点

- 主库写,从库读,降低服务器压力
- 在从服务器进行备份,避免备份期间影响主武器,保证数据安全
- 当主服务器出现问题时,可以切换到从服务器,提高性能

### #1.6.5 说说分库与分表设计分片

分库与分表的目的在于，减小数据库的单库单表负担，提高查询性能，缩短查询时间。
> 通过分表:

可以减少数据库的单表负担，将压力分散到不同的表上，同时因为不同的表上的数据量少了，起到提高查询性能，缩短查询时间的作用，此外，可以很大的缓解表锁的问题

分表策略可以归纳为垂直拆分和水平拆分。

> 水平分表: 

取模分表就属于随机分表，而时间维度分表则属于连续分表

如何设计好垂直拆分，我的建议：将不常用的字段单独拆分到另外一张扩展表. 将大文本的字段单独拆分到另外一张扩展表, 将不经常修改的字段放在同一张表中，将经常改变的字段放在另一张表中。

对于海量用户场景，可以考虑取模分表，数据相对比较均匀，不容易出现热点和并发访问的瓶颈。

> 库内分表:

仅仅是解决了单表数据过大的问题，但并没有把单表的数据分散到不同的物理机上，因此并不能减轻 MySQL 服务器的压力，仍然存在同一个物理机上的资源竞争和瓶颈，包括 CPU、内存、磁盘 IO、网络带宽等

> 分库与分表带来的分布式困境与应对之策

- 数据迁移与扩容问题:一般做法是通过程序先读出数据，然后按照指定的分表策略再将数据写入到各个分表中。
- 分页与排序问题:需要在不同的分表中将数据进行排序并返回，并将不同分表返回的结果集进行汇总和再次排序，最后再返回给用户。
分布式全局唯一ID—UUID、GUID等

## #1.7 B/B+树

### #1.7.1 为什么说B+树比B树更适合数据库索引？

- B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。
- B+树的查询效率更加稳定：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。
- 由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。

> B树在提高了IO性能的同时并没有解决元素遍历的我效率低下的问题，正是为了解决这个问题，B+树应用而生。B+树只需要去遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作或者说效率太低。

### #1.7.2 B/B+树性能分析

- n个节点的平衡二叉树的高度为H(即logn)，而n个节点的B/B+树的高度为logt((n+1)/2)+1； 
- 若要作为内存中的查找表，B树却不一定比平衡二叉树好，尤其当m较大时更是如此。因为查找操作CPU的时间在B-树上是O(mlogtn)=O(lgn(m/lgt))，而m/lgt>1；所以m较大时O(mlogtn)比平衡二叉树的操作时间大得多。因此在内存中使用B树必须取较小的m。（通常取最小值m=3，此时B-树中每个内部结点可以有2或3个孩子，这种3阶的B-树称为2-3树）。


### #1.7.3 数据库索引采用B+树而不是B树的主要原因

B+树只要遍历叶子节点就可以实现整棵树的遍历，而且在数据库中基于范围的查询是非常频繁的，而B树只能中序遍历所有节点，效率太低。