[TOC]

# 多路IO复用

## #1 名词概念

- 流 : 流可以是文件、socket(套接字)、pipe(管道)等可以进行I/O操作的对象
- I/O操作 : 可以从流中read(读)、write(写)数据


## #2 阻塞

### #2.1 阻塞 

#### #2.1.1 什么是阻塞 ? 

> 举个买火车票的例子 :

- 小明去火车站购买火车票,在火车站`排队干等`一天一夜,就是一直在排队,其他什么事也没做

#### 2.1.2 什么是非阻塞 ? 

> 还是火车票的例子 : 

- 小明去火车站购买火车票,这时购票员告知小明没有余票,回家等待
- 小明回家后,每隔30分钟就向售票员打电话,查询有没有余票
- 期间做了很多其他事


在`阻塞I/O模式`下,一个线程只能处理一个流的I/O事件。如果想要同时处理多个流,要么多进程,要么多线程,但是多进程和多线程的情况,效率都不高,且系统开销大

于是,`I/O非阻塞`出现,I/O非阻塞可以处理多个事件流,一个线程,从头到尾不停的遍历所有事件流,如果遇到需要处理的事件流,就处理,如果所有的事件流都没有数据,不需要处理,那么只会白白浪费CPU(`I/O非阻塞忙轮询`)


#### #2.1.3 什么是IO多路复用 ? 

1. select/poll

在上诉的I/O非阻塞情况下,线程需要不停的遍历所有的事件流,这样的做法显然不好

为了避免CPU空转，可以引进了一个代理(`select`、`poll`,select和poll本质没有区别),这个代理会监控很多事件流,当事件流没有数据的时候,就会把线程阻塞(挂起),当事件流有数据(可能是一个、多个或者所有)时(`就绪`),就会将线程从阻塞中`唤醒`,然后线程去遍历所有事件流(`I/O非阻塞无差别轮询`)


2. epoll

在上诉的select代理中,当线程得知有事件流需要处理时(`就绪`),线程并不知道是哪个线程需要处理(可能是一个、多个或者所有),这时就需要遍历所有的事件流,所以select的时间复杂度为O(n),这样的做法显然不够完美

于是,为了避免CPU做无用功(遍历查找认为是无用功),将select改进一下,为每一个事件流分配一个id和回调函数,当事件流有数据时,触发回调函数,将id返回给线程,此时线程就知道是哪一个事件流需要处理,时间复杂度也降到了O(1)


## #3 epoll 



## #4 select/poll/epoll区别






都是i/o多路复用的机制，监视多个socket是否发生变化，本质上都是同步i/o
    select,poll实现需要自己不断轮询所有监测对象，直到对象发生变化，在这个阶段中，
可能要睡眠和唤醒多次交替，而epoll也需要调用epoll_wait不断轮询就绪链表，但是当对象发生变化时，
会调用回调函数，将变化的对象放入就绪链接表中，并唤醒在epoll_wait中进入睡眠的进程。
虽然都会睡眠和唤醒，但是select和poll在被唤醒的时候要遍历整个监测对象集合，
而epoll只要判断就绪链表是否为空即可，节省了大量cpu的时间


 select、poll、epoll都是IO多路复用的机制，但select，poll，epoll本质上都是同步I/O，
 因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的.

FD(文件描述符)
select模型

优点：
    1：可移植性好，在某些Unix系统不支持poll()
    2：对于超时值提供了更好的精度：微妙，而poll是毫秒
缺点：
    1:最大并发数限制，因为一个进程所打开的 FD （文件描述符）是有限制的，由 FD_SETSIZE 设置，默认值是 1024/2048 ，因此 Select 模型的最大并发数就被相应限制了。
    2：效率问题，select每次调用都会线性扫描全部的FD集合，所以将FD_SETSIZE 改大，会越慢
    3：需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大。 

poll本质上和select 没有区别，它将用户传入的数组拷贝到内核空间，
它没有最大连接数的限制，原因是它基于链表来存储的但是同样有一个缺点：
大量的fd的数组被整体复制于用户态和内核地址空间，而不管这样的复制是不是有意义



