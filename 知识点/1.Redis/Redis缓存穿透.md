[TOC]


# Redis 缓存穿透/缓存雪崩/缓存击穿


![](https://raw.githubusercontent.com/Coxhuang/yosoro/master/19CAF036-4CE6-4CD4-9806-BB77D48851AE.png)


## #1 什么是缓存穿透？如何避免？？

> 缓存穿透:

缓存穿透，是指查询一个数据库一定不存在的数据。正常的使用缓存流程大致是，数据查询先进行缓存查询，如果key不存在或者key已经过期，再对数据库进行查询，并把查询到的对象，放进缓存。如果数据库查询对象为空，则不放进缓存
。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。

- 参数传入对象主键ID
- 根据key从Redis中获取对象
- 如果对象不为空，直接返回
- 如果对象为空，进行数据库查询
- 如果从数据库查询出的对象不为空，则放入缓存

如果传入一个在Redis和后端数据库都不存在的key,Redis和后端数据库都查找了一遍,且因为在后端数据库找不到,不会存到Redis中,那么,就导致一个恶意的请求,两个数据库都遍历一遍


> 如何避免？

- 对后端数据库查询结果为空的情况也进行缓存，缓存时间设置短一点，比如设置为60秒。
- 接口层增加校验,如用户鉴权校验,id做基础校验,id<=0的直接拦截
- 使用布隆过滤器,将所有可能存在的数据哈希到一个足够大的bitmap中,一个一定不存在的数据会被 这个bitmap拦截掉,从而避免了对底层存储系统的查询压力



## #2 什么是缓存雪崩？何如避免

> 缓存雪崩

当缓存服务器重启或者大量缓存集中在某一个时间段集中过期失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。

> 例子

- 马上就要到双十一零点，很快就会迎来一波抢购，这波商品时间比较集中的放入了缓存，假设缓存一个小时。那么到了凌晨一点钟的时候，这批商品的缓存就都过期了。而对这批商品的访问查询，都落到了数据库上，对于数据库而言，就会产生周期性的压力波峰。

> 缓存失效后:

![](https://raw.githubusercontent.com/Coxhuang/yosoro/master/20200313150558.png)


> 如何避免？

- 在缓存失效后，通过加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写,从而避免失效时大量的并发请求落到底层存储系统上。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待,加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！
- 做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期
- 不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀,比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机。
- 如果缓存数据库是分布式部署，将热点数据均匀分布在不同的缓存数据库中。


## #3 什么是缓存击穿？何如避免

> 缓存击穿

缓存击穿，是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

> 如何避免? 

- 设置热点数据永远不过期  


## #4 什么是缓存预热? 

> 系统上线时，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。

- 可以将已知的热门数据加载到Redis，这种方法适合于基本不变化的数据；
- 使用redis-faina（https://github.com/facebookarchive/redis-faina.git）实时监控Redis热key，但是因为redis-faina是通过调用Redis的monitor命令来实现的，可能降低Redis50%左右的性能，所以需要根据实际情况评估；



