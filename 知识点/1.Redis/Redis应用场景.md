[TOC]

# Redis应用场景


## #1 Redis应用场景

- 缓存
- 排行榜
- 计数器
- 队列
- 最新列表
- 分布式锁


## #2 缓存

Redis的字符串、哈希表两种数据结构适合用来储存大量的键值对信息，从而实现高速缓存。合理的利用缓存不仅能够提升网站访问速度，还能大大降低数据库的压力。Redis提供了键过期功能，也提供了灵活的键淘汰策略，所以，现在Redis用在缓存的场合非常多。

## #3 排行榜

很多网站都有排行榜应用的，如淘宝的月度销量榜单、商品按时间的上新排行榜等。Redis提供的有序集合数据类构能实现各种复杂的排行榜应用。Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构

- zset可以用来存储粉丝列表,value值是粉丝的ID,score是关注的时间,我们乐意对粉丝列表按关注时间进行排序
- zse还可以用来存储学生的成绩,value值是学生的ID,score是他的成绩,我们可以对成绩按分数进行排序就可以得到他的名次


```
127.0.0.1:6379> zadd books 9.0 "Python"
(integer) 1
127.0.0.1:6379> zadd books 8.8 "JavaScript"
(integer) 1
127.0.0.1:6379> zadd books 8.1 "Golang"
(integer) 1
127.0.0.1:6379> zadd books 8.0 "Golang"
(integer) 0
(integer) 0
127.0.0.1:6379> zrange books 0 -1 # 0 表示有序集第一个成员， -1 表示最后一个成员
1) "Golang"
2) "JavaScript"
3) "Python"
127.0.0.1:6379> zrange books 0 10
1) "Golang"
2) "JavaScript"
3) "Python"
127.0.0.1:6379> zrevrange books 0 10 # 倒序
1) "Python"
2) "JavaScript"
3) "Golang"
```

## #4 计数器

什么是计数器，如电商网站商品的浏览量、视频网站视频的播放数等。为了保证数据实时效，每次浏览都得给+1，并发量高时如果每次都请求数据库操作无疑是种挑战和压力。Redis提供的incr命令来实现计数器功能，内存操作，性能非常好，非常适用于这些计数场景。


```
127.0.0.1:6379> SET rank 50
OK
127.0.0.1:6379> INCRBY rank 20
(integer) 70
127.0.0.1:6379> GET rank
"70"
```

## #5 队列

- 使用"列表"数据结构，可以实现普通级和优先级队列的功能
- 使用"有序集合"数据结构，可以实现优先级队列
- 使用"哈希表"数据结构，可以实现延时队列

### #5.1 Redis和RabbitMQ区别

1. 可靠性

- Redis ：没有相应的机制保证消息的可靠消费，如果发布者发布一条消息，而没有对应的订阅者的话，这条消息将丢失，不会存在内存中；
- RabbitMQ：具有消息消费确认机制，如果发布一条消息，还没有消费者消费该队列，那么这条消息将一直存放在队列中，直到有消费者消费了该条消息，以此可以保证消息的可靠消费

2. 实时性

- Redis : 实时性高，redis作为高效的缓存服务器，所有数据都存在内存中，所以它具有更高的实时性

3. 消费者负载均衡

- Redis : 发布订阅模式，一个队列可以被多个消费者同时订阅，当有消息到达时，会将该消息依次发送给每个订阅者，她是一种消息的广播形式，redis本身不做消费者的负载均衡，因此消费效率存在瓶颈；
- RabbitMQ 队列可以被多个消费者同时监控消费，但是每一条消息只能被消费一次，由于rabbitmq的消费确认机制，因此它能够根据消费者的消费能力而调整它的负载；

4. 持久性

- Redis : redis的持久化是针对于整个redis缓存的内容，它有RDB和AOF两种持久化方式（redis持久化方式，后续更新），可以将整个redis实例持久化到磁盘，以此来做数据备份，防止异常情况下导致数据丢失。
- RabbitMQ : 队列，每条消息都可以选择性持久化，持久化粒度更小，更灵活；

5. 队列监控

- Redis : 没有所谓的监控平台。
- RabbitMQ : 实现了后台监控平台，可以在该平台上看到所有创建的队列的详细情况，良好的后台管理平台可以方面我们更好的使用；

> 总结

- Redis : 轻量级，低延迟，高并发，低可靠性；
- RabbitMQ : 重量级，高可靠，异步，不保证实时；
- RabbitMQ 是一个专门的AMQP协议队列，他的优势就在于提供可靠的队列服务，并且可做到异步，而redis主要是用于缓存的，redis的发布订阅模块，可用于实现及时性，且可靠性低的功能。






## #6 最新列表

Redis列表结构，RPUSH/LPUSH可以在列表插入一个内容ID作为关键字，LTRIM可用来截取列表的数量，每插入一条数据就调用一次LTRIM(这也是官方给的方法),就可以获取最近的数据。


```
127.0.0.1:6379> RPUSH mylist "hello"
(integer) 1
127.0.0.1:6379> RPUSH mylist "hello"
(integer) 2
127.0.0.1:6379> RPUSH mylist "foo"
(integer) 3
127.0.0.1:6379> RPUSH mylist "bar"
(integer) 4
127.0.0.1:6379> LTRIM mylist 1 -1
OK
127.0.0.1:6379> LRANGE mylist 0 -1
1) "hello"
2) "foo"
3) "bar"
127.0.0.1:6379> RPUSH mylist "haha"
(integer) 4
127.0.0.1:6379> RPUSH mylist "xoxo"
(integer) 5
127.0.0.1:6379> LRANGE mylist 0 -1
1) "hello"
2) "foo"
3) "bar"
4) "haha"
5) "xoxo"
```

## #7 分布式锁

分布式技术带来的技术挑战是对同一个资源的并发访问，如全局ID、减库存、秒杀等场景，并发量不大的场景可以使用数据库的悲观锁、乐观锁来实现，但在并发量高的场合中，利用数据库锁来控制资源的并发访问是不太理想的，大大影响了数据库的性能。可以利用Redis的setnx功能来编写分布式的锁，如果设置返回1说明获取锁成功，否则获取锁失败，实际应用中要考虑的细节要更多

- 秒杀系统，基于redis是单线程特征，防止出现数据库“爆破”
- 全局增量ID生成，类似“秒杀”




