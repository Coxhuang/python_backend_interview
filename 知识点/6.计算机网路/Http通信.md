[TOC]


# 计算机网路

![](https://raw.githubusercontent.com/Coxhuang/yosoro/master/TCPIP.png)



## #1 Https原理

## # HTTPS的工作原理

我们都知道HTTPS能够加密信息，以免敏感信息被第三方获取，所以很多银行网站或电子邮箱等等安全级别较高的服务都会采用HTTPS协议。


客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。

1. 客户端-->服务端 : 客服端发送当前客户端支持的算法集合(加密协议)
2. 服务端-->客户端 : 返回合适的算法集合
3. 服务端-->客户端 : 向客户端下发证书和公钥
4. 客户端验证 : 客户端使用公钥验证证书的合法性
5. 客户端-->服务端 : 客户端生成随机数n,并使用公钥对随机数n加密,将加密后的随机数发送给服务端
6. 服务端-->客户端 : 服务端使用秘钥将随机数解密,并使用随机数n对需要发送的数据进行对称加密,发送给客户端
7. 客户端 : 客户端使用随机数对服务端发来的数据进行解密

![20200310005651-image.png](https://raw.githubusercontent.com/Coxhuang/yosoro/master/20200310005651-image.png)



## #2 Http和Https的的区别

- https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用
- HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
- http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443
- http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全


## #3 http1.0和http1.1的区别

- 缓存处理：1.1添加更多的缓存控制策略（如：Entity tag，If-Match）
- 网络连接的优化：1.1支持断点续传
- 错误状态码的增多：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态
- Host头处理：支持Host头域，不在以IP为请求方标志
- 长连接：减少了建立和关闭连接的消耗和延迟。


## #4 http1.1和http2.0的区别

- 新的传输格式：2.0使用二进制格式，1.0依然使用基于文本格式
- 多路复用：连接共享，不同的request可以使用同一个连接传输（最后根据每个request上的id号组合成正常的请求）
- header压缩：由于1.X中header带有大量的信息，并且得重复传输，2.0使用encoder来减少需要传输的hearder大小
- 服务端推送：同google的SPDUY（1.0的一种升级）一样


## # TCP三次握手和四次挥手

### # 三次握手 


![20200307181410-image.png](https://raw.githubusercontent.com/Coxhuang/yosoro/master/20200307181410-image.png)


1. 建立连接时，客户端发送seq包(seq=x)到服务器,并进入SYN_SENT状态,等待服务器确认;SYN : 同步序列编号(Synchronize Sequence Numbers)。
2. 服务器收到seq包,必须确认客户的SYN(ack=x+1),同时自己也发送一个SYN包(seq=y),即SYN+ACK包，此时服务器进入SYN_RECV状态；
3. 客户端收到服务器的SYN+ACK包,向服务器发送确认包ACK(ack=y+1),此包发送完毕,客户端和服务器进入ESTABLISHED(TCP连接成功)状态,完成三次握手。


**完成三次握手，客户端与服务器开始传送数据**


### # 四次挥手

![20200307181716-image.png](https://raw.githubusercontent.com/Coxhuang/yosoro/master/20200307181716-image.png)

1. 断开连接时,客户端发送seq包(seq=u)到服务器,并进入ESTAB_LISHED状态,等待服务器确认
2. 服务器收到seq包,向客户端发送确认包ACK(seq=u+1),即ACK包，此时服务器进入ClOSE_WAIT状态；
3. 等待服务器发送完真实数据后,发送FIN信号,表示,可以断开连接
4. 客户端发送ACK信号,表示已经收到


### # 面试题

#### # 为什么连接的时候是三次握手，关闭的时候是四次握手？


因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。


#### # 为什么不能用两次握手进行连接？

3次握手完成两个重要的功能，既要双方做好发送数据的准备工作（双方都知道彼此已准备好），也要允许双方就出事序列号进行协商，这个序列号在握手过程中被发送和确认。现在把三次握手改成仅需要两次握手，死锁是可能发生的。

#### # 为什么在第四次挥手时,客户端需要等待2MSL后才能关闭链接 ? 

> MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”, 2MSL就是一来一回所需要的时间

1. 假设,客户端发起的第四次挥手,在中间某处断开了,信号没有传到服务端,服务端经过一个2MSL,发现没有收到客户端的ACK(第四次挥手信号),服务端就会认为:自己的第三次挥手信号没有送达到客户端,这时会重新发送第三次挥手信号
2. 但是客户端确实已经收到了第三次挥手的信号,如果客户端收到第三次挥手的信号,直接关闭,那么,服务端会认为是自己的第三次挥手没有送达,每个2MSL就发一次第三次挥手
3. 导致一个问题,如果碰巧,下一次客户端创建一个新的连接时,端口号和ip完全一样,这时,之前服务端发送的第三次挥手信号和数据,会全部发到新建连接的客户端上

> http://dy.163.com/v2/article/detail/EENRSF0705315U6Q.html

## # UDP和TCP协议


### # UDP协议

> 全称是用户数据报协议,在网络中它与TCP协议一样用于处理数据包,具有以下特点:

1. 无连接 : 发送数据前不需要建立连接发送完数据也不需要释放连接
2. 尽最大努力交付
3. 面向报文 : 应用程序每次给下层交付一个报文，应用程序需要选择合适的报文尺寸。若报文太小，相对来说使得报文段首部太大，影响传输效率；若报文太大，交给传输层可能要进行分片，也降低效率。
4. 没有拥塞控制，会因为一些网络状况丢失一些数据，不过实时性强
5. 支持一对一、一对多、多对一以及多对多的交互通信
6. UDP头部开销小  只有8字节
7. 发送方发送一次   接收端也只接收一次   如果一次接收没有完  剩余的就会被丢弃












> 优点：在某些实时性要求高的场景（比如电话会议）就需要使用UDP而不是TCP


### # TCP协议

1. 面向连接

- 在发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接

2. 仅支持单播传输

- 每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播的传输方式(每一条tcp连接只能是1对1的)


3. 面向字节流

- 不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。

4. 可靠传输

- 判断丢包，误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接受端实体的包的按序接收，然后接受端实体对已成功收到的字节发回一个相应的确认（ACK）；如果发送端实体在合理的往返时延内未收到确认，那么对应的数据（假设丢失了）将会被重传

5. 提供拥塞控制

- 当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞

6. 提供全双工通信

- 允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）

### # 面试题

#### # 为什么tcp可靠，哪些方法保证可靠

- 确认和重传机制 : 建立连接时三次握手同步双方的“序列号 + 确认号 + 窗口大小信息”，是确认重传、流控的基础,传输过程中，如果Checksum校验失败、丢包或延时，发送端重传。
- 数据排序 : TCP有专门的序列号SN字段，可提供数据re-order
- 流量控制 : 滑动窗口和计时器的使用。TCP窗口中会指明双方能够发送接收的最大数据量，发送方通过维持一个发送滑动窗口来确保不会发生由于发送方报文发送太快接收方无法及时处理的问题。
- 拥塞控制



#### # tcp粘包是怎么回事，如何处理？udp有粘包吗？

> 什么是TCP粘包 ? 

关于TCP的粘包 正是由于TCP是流式传送的 也就是连接建立后可以一直不停的发送 并没有明确的边界定义

UDP发送的时候 是可以按照一个一个数据包去发送的 一个数据包就是一个明确的边界

> UDP丢包 

UDP丢包是因为数据包在传送过程中丢失了 而TCP是基于流式的发送 并且存在丢包重发机制 TCP是可靠连接而UDP是不可靠的


> 粘包的处理

1. 什么时候需要处理

- 如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象
- 如果多个分组毫不相干，甚至是并列关系，这个时候就一定要处理粘包现象了。

2. 如何处理

- 发送方 : 对于发送方造成的粘包问题，可以通过关闭Nagle算法来解决，使用TCP_NODELAY选项来关闭算法。
- 接收方 : 接收方没有办法来处理粘包现象，只能将问题交给应用层来处理。
- 应用层 : 循环处理，应用程序从接收缓存中读取分组时，读完一条数据，就应该循环读取下一条数据，直到所有数据都被处理完成


> UDP没有粘包 

TCP为了保证可靠传输并减少额外的开销（每次发包都要验证），采用了基于流的传输，基于流的传输不认为消息是一条一条的，是无保护消息边界的（保护消息边界：指传输协议把数据当做一条独立的消息在网上传输，接收端一次只能接受一条独立的消息）。

UDP则是面向消息传输的，是有保护消息边界的，接收方一次只接受一条独立的信息，所以不存在粘包问题。



















